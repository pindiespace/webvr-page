<!DOCTYPE html>
<html lang="en">
<head>
<title>Web VR Page Boilerplate</title>
<meta charset="utf-8">

<!--favicon-->
<link rel="icon" href="img/favicon.ico">

<!--set the viewport, shrink-to-fit fixes safari bug-->
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0 shrink-to-fit=no">

<!--Web manifest.-->
<link rel="manifest" href="manifest.webmanifest">

<!--
handle iOS and android mobile
http://www.html5rocks.com/en/mobile/fullscreen/
ios fullscreen
-->
<meta name="apple-mobile-web-app-capable" content="yes">

<!--android fullscreen-->
<meta name="mobile-web-app-capable" content="yes">

<!--hide the Apple status bar-->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!--default styles-->
<link rel="stylesheet" href="css/styles.css">

<!--
Detector script. Determine if polyfills needed. Couple with a loader
like head.js
-->
<script src="js/lib/feature-detector.js"></script>

</head>

<body>
  <header>
    <h1>WebVR - DOM Page-Friendly Boilerplate</h1>
    <nav class="menu">
      <ul>
        <li><button id="go-fullscreen">Go Fullscreen</button></li>
        <li><span>Load Progress:</span><progress id='webvr-page-load-progress' value='0' max='100'><span>0</span>%</progress></li>
      </ul>
    </nav>
  </header>
  <main>
    <section>
      <h2>Page Section</h2>
      <!--webvr sample goes here-->
      <article id="sample-webvr">
        <figure class="webvr-page">
          <canvas id='scene-cube'>Canvas is not enabled, upgrade your browser</canvas>
          <figcaption>Cube World</figcaption>
        </figure>
      </article>
      <!--second webvr sample goes here-->
      <article id="second-webvr">
        <figure class="webvr-page">
          <canvas id='scene-text'>Canvas is not supported, upgrade your browser.</canvas>
          <figcaption>3D Text World</figcaption>
        </figure>
      </article>
    </section>
  </main>
  <footer>
    <h2>Page Footer</h2>
  </footer>

<!--
  Canvas renderer (from threejs examples) for one-time render in browsers lacking WebGL,
  in particular, IE9 and IE10.
-->
<!--<script src="js/lib/Projector.js"></script>-->
<!--<script src="js/lib/CanvasRenderer.js"></script>-->

<!--
  VREffect.js handles stereo camera setup and rendering. NOTE: this needs to load before VRControls.js
  NOTE: needs setFOV() added to work!
  -->
<!--<script src="js/lib/VREffect.js"></script>-->

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<!--<script src="js/lib/VRControls.js"></script>-->

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script>
  /*
   * This configures the app to use webvr-polyfill if desired, along with other params.
   */
  WebVRConfig = {
     // Forces availability of VR mode.
     FORCE_ENABLE_VR: true // Default: false. Enables VR toggles on Desktops.
     //FORCE_DISTORTION: true, // Default: false.
     // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
     //K_FILTER: 0.98, // Default: 0.98.
     // How far into the future to predict during fast motion.
     //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
     // Flag to disable touch panner. In case you have your own touch controls
     //TOUCH_PANNER_DISABLED: true, // Default: false.
     // Enable yaw panning only, disabling roll and pitch. This can be useful for
     // panoramas with nothing interesting above or below.
     //YAW_ONLY: true, // Default: false.
   };
</script>

<!--
  set up the VR scene.
-->
<script>
/*
 * Feature-detect <canvas> support and WebGL API using FeatureDetector.js.
 * The <canvas> tag can't be polyfilled for VR, and addEventListener is supported by all browsers which support <canvas>
 * More tests at: https://github.com/facebookarchive/rng.io/blob/c96a962ec18beef5f456d04820d791cbda59c2bc/dist/tests.js
*/
if(!FeatureDetector.addEventListener || !FeatureDetector.canvas) {
  //the <canvas> tags will display our error message (one reason for putting them into markup).
  //TODO: polyfill with blank GIF image.
} else {

// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
document.addEventListener('DOMContentLoaded', function() {

  /*
   * 1. Load JS Polyfills required for a VR scene.
   * Promise polyfill by taylorhakes
   * https://github.com/taylorhakes/promise-polyfill
   * Fetch polyfill.
   * https://github.com/github/fetch
   * ES5 methods (es5.js) for Object() methods.
   * DOM methods and properties (dom.js) including querySelector(), querySelectorAll(), .classList.
   * Typed array polyfill (typedArray.js) for ie9 running canvas renderer.
   * typedarray.js by inexorabletrash
   * https://github.com/inexorabletash/polyfill
   *
   * 2. Load JS Libraries.
   * three.js 3d library by mrdoob
   * CanvasRenderer for fallback from WebGL (static images).
   * Projector.js for Canvas rendering.
   * VREffect.js for stereo rendering.
   * VRControls.js for correct VR events.
   * https://github.com/mrdoob/three.js/
   */
  FeatureDetector.load([
    [
      {name: 'querySelectorAll', poly: 'js/lib/dom.js'},
      {name: 'defineProperty', poly: 'js/lib/es5.js'},
      {name: 'typedArray', poly: 'js/lib/typedarray.js'},
      {name: 'promise', poly: 'js/lib/Promise.min.js'},
      {name: 'three', poly: 'js/lib/three.min.js'}
    ],
    [
      {name: 'projector', poly: 'js/lib/Projector.js'},
      {name: 'canvasRenderer', poly: 'js/lib/CanvasRenderer.js'},
      {name: 'VREffect', poly: 'js/lib/VREffect.js'},
      {name: 'VRControls', poly: 'js/lib/VRControls.js'}
    ],
    [
      {name: 'WebVRPolyfill', poly: 'js/lib/webvr-polyfill.js'}
    ],
    [
      {name: 'Fetch', poly: 'js/lib/fetch.js'},
      {name: 'WebVRPage', poly: 'js/webvr-page.js'}
    ]
  ], function() {
    console.log('callback');

    // Example at: https://github.com/jeromeetienne/threejsboilerplate/blob/master/index.html4
    document.getElementById('go-fullscreen').addEventListener('click', function(e) {
      manager.requestFullscreen();
    }.bind(this), false);

    // Use an existing <canvas> in the markup.
    var canvas = document.getElementById('scene-cube');
    var renderer;
    if(FeatureDetector.webgl) { // 3D scenes ok.
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        canvas: canvas
      });
      renderer.setPixelRatio(window.devicePixelRatio);
    } else { // Can't do 3d, just draw the scene once and use as a fallback image.
    console.warn('no webgl, fallback to canvas still image rendering of scene');
    renderer = new THREE.CanvasRenderer({
      antialias: true,
      canvas: canvas
    });
  }

  // Canvas size determined by markup, not JS.
  var w = parseFloat(getComputedStyle(canvas).getPropertyValue('width'));
  var h = parseFloat(getComputedStyle(canvas).getPropertyValue('height'));
  var aspect = w/h;

  /*
  * Params for the Manager.
  * hidebutton: if true, don't show buttons
  * detector: if present, we can used the feature detections later.
  */

  // Create a three.js camera.
  var camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 10000);

  // Apply VR headset positional data to camera.
  var controls = new THREE.VRControls(camera);

  /////////////////////////////////////////////////////////////////////
  THREE.VREffect.prototype.setFOV = function(FOVL, FOVR) {
    eyeFOVL = FOVL;
    eyeFOVR = FOVR;
  };
  /////////////////////////////////////////////////////////////////////

  // Apply VR stereo rendering to renderer.
  var effect = new THREE.VREffect(renderer);
  effect.setSize(w, h);

  // Create a Manager.
  window.manager = new WebVRPageManager(renderer, effect, camera, {hideButton: false, detector: (FeatureDetector || THREE.Detector)});

  // Create a three.js scene.
  var scene = new THREE.Scene();

  // Add a repeating grid as a skybox.
  var boxWidth = 5;
  var texture = THREE.ImageUtils.loadTexture(
    'img/box.png'
  );
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxWidth, boxWidth);

  var geometry = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });

  var skybox = new THREE.Mesh(geometry, material);
  window.skybox = skybox;

  // Add a separate uuid from the one THREE generates (crypto-secure).
  skybox.userData.uuid = WebVRPageManager.Util.getUUID();

  // Name it (so we could use .getObjectByName() later). Leave the generated .id alone.
  skybox.name = 'skybox';

  scene.add(skybox);

  // Create 3D objects.
  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  var material = new THREE.MeshNormalMaterial();
  var cube = new THREE.Mesh(geometry, material);

  // Add a separate uuid from the one THREE generates (crypto-secure).
  cube.userData.uuid = WebVRPageManager.Util.getUUID();

  // Name it.
  cube.name = 'spinning cube';

  // Position cube mesh
  cube.position.z = -1;

  // Add cube mesh to your three.js scene
  scene.add(cube);

  // Reset the position sensor when 'z' pressed.
  function onKey(event) {
    if (event.keyCode == 90) { // z
      controls.resetSensor();
    }
  }
  window.addEventListener('keydown', onKey, true);

  // Request animation frame loop function
  function animate(timestamp) {
    // Apply rotation to cube mesh
    cube.rotation.y += 0.01;

    // Update VR headset position and apply to camera.
    controls.update();

    // Render the scene through the manager.
    manager.render(scene, camera, timestamp);

    requestAnimationFrame(animate);
  }

  // Kick off animation loop, or draw a still image one time.
  if(FeatureDetector.webgl) { // Render animated 3D scene.
    animate();
  } else { // Render exactly once to canvas, treat as image.
    manager.render(scene, camera);
  }

  //END OF CALLBACK FOR LOADER

  }, function(percent) {
    console.log('progress function, ' + percent + '%');
    var prog = document.getElementById('webvr-page-load-progress');
    if(prog) {
      prog.value = percent;
      prog.getElementsByTagName('span')[0].innerHTML = percent;
    }
  }, function(s, loadCount) {
    console.log('failed to load:' + s.src + ' count:' + loadCount);
  }); // End of Loader callback.

}); //end of DOMCOntentLoaded callback.

// Things to do once ALL content is loaded (i.e. window.onload).
window.addEventListener('load', function(e) {

});

} // End of conditional for un-polyfill-able features.

</script>
</body>
</html>
