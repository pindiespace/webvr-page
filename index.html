<!DOCTYPE html>
<html lang="en">
<head>
<title>Web VR Page Boilerplate</title>
<meta charset="utf-8">

<!--favicon-->
<link rel="icon" href="img/favicon.ico">

<!--set the viewport, shrink-to-fit fixes safari bug-->
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0 shrink-to-fit=no">

<!--Web manifest.-->
<link rel="manifest" href="manifest.webmanifest">

<!--
handle iOS and android mobile
http://www.html5rocks.com/en/mobile/fullscreen/
ios fullscreen
-->
<meta name="apple-mobile-web-app-capable" content="yes">

<!--android fullscreen-->
<meta name="mobile-web-app-capable" content="yes">

<!--hide the Apple status bar-->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!--default styles-->
<link rel="stylesheet" href="css/styles.css">

<!--
Detector script. Determine if polyfills needed. Couple with a loader
like head.js
-->
<script src="js/lib/feature-detector.js"></script>
</head>

<body>
  <header>
    <h1>WebVR - DOM Page-Friendly Boilerplate</h1>
    <div class="menu">
      <button id="go-fullscreen">Go Fullscreen</button>
    </div>
  </header>
  <main>
    <section>
      <h2>Page Section</h2>
      <!--webvr sample goes here-->
      <article id="sample-webvr">
        <figure class="webvr-page">
          <canvas id='scene-cube'>Canvas is not enabled, upgrade your browser</canvas>
          <figcaption>Cube World</figcaption>
        </figure>
      </article>
      <!--second webvr sample goes here-->
      <article id="second-webvr">
        <figure class="webvr-page">
          <canvas id='scene-text'>Canvas is not supported, upgrade your browser.</canvas>
          <figcaption>3D Text World</figcaption>
        </figure>
      </article>
    </section>
  </main>
  <footer>
    <h2>Page Footer</h2>
  </footer>

<!--
  ES5 and DOM menthod polyfills.
-->
<script src="js/lib/dom.js"></script>
<script src="js/lib/es5.js"></script>

<!--
  Promise polyfill by taylorhakes
  https://github.com/taylorhakes/promise-polyfill
-->
<script src="js/lib/Promise.min.js"></script>

<!--
for ie9 running canvas renderer.
typedarray.js by inexorabletrash
https://github.com/inexorabletash/polyfill
-->
<script src="js/lib/typedarray.js"></script>

<!--
  three.js 3d library by mrdoob
  https://github.com/mrdoob/three.js/
  typedarray.js by inexorabletrash
  https://github.com/inexorabletash/polyfill
  -->
<script src="js/lib/three.min.js"></script>

<!--
  Canvas renderer (from threejs examples) for one-time render in browsers lacking WebGL,
  in particular, IE9 and IE10.
-->
<script src="js/lib/Projector.js"></script>
<script src="js/lib/CanvasRenderer.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering. NOTE: this needs to load before VRControls.js
  NOTE: needs setFOV() added to work!
  -->
<script src="js/lib/VREffect.js"></script>

<!--
  Add a function for setting the FOV dynamically. Used to support VR scene correct scaling even if the device orientation changes.
-->
<script>
  THREE.VREffect.prototype.setFOV = function(FOVL, FOVR) {
    eyeFOVL = FOVL;
  	eyeFOVR = FOVR;
  };
</script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="js/lib/VRControls.js"></script>

<!--
  Fix the filter function so it returns values if .deviceName isn't defined.
-->
<script>
if(!THREE.VRControls.filterInvalidDevices) {
THREE.VRControls.filterInvalidDevices = function( devices ) {

  // Exclude Cardboard position sensor if Oculus exists.

  var oculusDevices = devices.filter( function ( device ) {

    if (device && device.deviceName) {

      return device.deviceName.toLowerCase().indexOf( 'oculus' ) !== - 1;

    }

  } );

  if ( oculusDevices.length >= 1 ) {

    return devices.filter( function ( device ) {

      if(device && device.deviceName) {

        return device.deviceName.toLowerCase().indexOf( 'cardboard' ) === - 1;

      }

    } );

  } else {

    return devices;

  }

} //end of function.
} // end of test.
</script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script>
  /*
   * This configures the app to use webvr-polyfill if desired, along with other params.
   */
  WebVRConfig = {
     // Forces availability of VR mode.
     FORCE_ENABLE_VR: true, // Default: false. Enables VR toggles on Desktops.
     //FORCE_DISTORTION: true, // Default: false.
     // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
     //K_FILTER: 0.98, // Default: 0.98.
     // How far into the future to predict during fast motion.
     //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
     // Flag to disable touch panner. In case you have your own touch controls
     //TOUCH_PANNER_DISABLED: true, // Default: false.
     // Enable yaw panning only, disabling roll and pitch. This can be useful for
     // panoramas with nothing interesting above or below.
     //YAW_ONLY: true, // Default: false.
   };
</script>

<script src="js/lib/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js/webvr-page.js"></script>

<!--
  set up the VR scene.
-->
<script>
// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
document.addEventListener('DOMContentLoaded', function() {

  // Feature-detect <canvas> support and WebGL API using THREE.js webvr-detector.js (in examples).
  // More sophsiticated tests at: https://github.com/facebookarchive/rng.io/blob/c96a962ec18beef5f456d04820d791cbda59c2bc/dist/tests.js
  if(!FeatureDetector.canvas) {
    //the <canvas> tags will display our error message (one reason for putting them into markup).
    return;
  }

  // Example at: https://github.com/jeromeetienne/threejsboilerplate/blob/master/index.html4
  document.getElementById('go-fullscreen').addEventListener('click', function(e) {
    manager.requestFullscreen();
  }.bind(this), false);

// Use an existing <canvas> in the markup.
var canvas = document.getElementById('scene-cube');
var renderer;
if(FeatureDetector.webgl) { // 3D scenes ok.
  renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas
  });
  renderer.setPixelRatio(window.devicePixelRatio);
} else { // Can't do 3d, just draw the scene once and use as a fallback image.
  console.warn('no webgl, fallback to canvas still image rendering of scene');
  renderer = new THREE.CanvasRenderer({
    antialias: true,
    canvas: canvas
  });
}

// Canvas size determined by markup, not JS.
var w = parseFloat(getComputedStyle(canvas).getPropertyValue('width'));
var h = parseFloat(getComputedStyle(canvas).getPropertyValue('height'));
var aspect = w/h;

/*
 * Params for the Manager.
 * hidebutton: if true, don't show buttons
 * detector: if present, we can used the feature detections later.
 */

 // Create a three.js camera.
 var camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 10000);

 // Apply VR headset positional data to camera.
 var controls = new THREE.VRControls(camera);

 // Apply VR stereo rendering to renderer.
 var effect = new THREE.VREffect(renderer);
 effect.setSize(w, h);

// Create a Manager.
window.manager = new WebVRPageManager(renderer, effect, camera, {hideButton: false, detector: (FeatureDetector || THREE.Detector)});

// Create a three.js scene.
var scene = new THREE.Scene();

// Add a repeating grid as a skybox.
var boxWidth = 5;
var texture = THREE.ImageUtils.loadTexture(
  'img/box.png'
);
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(boxWidth, boxWidth);

var geometry = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
var material = new THREE.MeshBasicMaterial({
  map: texture,
  color: 0x01BE00,
  side: THREE.BackSide
});

var skybox = new THREE.Mesh(geometry, material);
window.skybox = skybox;

// Add a separate uuid from the one THREE generates (crypto-secure).
skybox.userData.uuid = WebVRPageManager.Util.getUUID();

// Name it (so we could use .getObjectByName() later). Leave the generated .id alone.
skybox.name = 'skybox';

scene.add(skybox);

// Create 3D objects.
var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(geometry, material);

// Add a separate uuid from the one THREE generates (crypto-secure).
cube.userData.uuid = WebVRPageManager.Util.getUUID();

// Name it.
cube.name = 'spinning cube';

// Position cube mesh
cube.position.z = -1;

// Add cube mesh to your three.js scene
scene.add(cube);

// Reset the position sensor when 'z' pressed.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.resetSensor();
  }
}
window.addEventListener('keydown', onKey, true);

// Request animation frame loop function
function animate(timestamp) {
  // Apply rotation to cube mesh
  cube.rotation.y += 0.01;

  // Update VR headset position and apply to camera.
  controls.update();

  // Render the scene through the manager.
  manager.render(scene, camera, timestamp);

  requestAnimationFrame(animate);
}

// Kick off animation loop, or draw a still image one time.
if(FeatureDetector.webgl) { // Render animated 3D scene.
  animate();
} else { // Render exactly once to canvas, treat as image.
  manager.render(scene, camera);
}


}); //end of DOMCOntentLoaded callback.

// Things to do once ALL content is loaded.
window.addEventListener('load', function(e) {

});

</script>
</body>
</html>
